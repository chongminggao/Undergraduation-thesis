% !Mode:: "TeX:UTF-8"

\chapter{动态双边聚类算法\emph{CoSync}}
\label{chapter:main}
\section{双聚类问题的全新切入点}
就如同上一章中回顾的那样，对于双边聚类问题已有各式各样的方法来解决。在我们这次工作中，我们将要使用一种全新的思想来看待这个问题，即\emph{动态交互}。在这种角度下，我们把整个数据的关联矩阵视为一个动态系统，用同步交互的方式来自动地引导矩阵中值的变化。

我们用图\ref{idea}说明如何从矩阵中用这种自动的交互得到联合簇。对于一个数据集的交互矩阵$A$中每一个元素$e_{ij}$所在行和列，我们首先找寻相关的行与列，即与选定行或列距离小于一定阈值的行或列。随后找到的相关的行或列中下标对应为$i$或$j$的元素，即图\ref{idea}(b)中与红色小框同行或同列的蓝色和橘色小框所代表的元素，让它们对$e_{ij}$产生动态的加权交互，体现为一个“引力”，使得交互的结果趋近于缩小差值。这个过程将一直迭代下去直至收敛，收敛后对矩阵行列重新排序，得到结果矩阵如\ref{idea}(c)所示。

\pic[!htb]{\cosync算法中矩阵元素在行列上的动态交互示意图 (a)关联矩阵的原始状态图，颜色深浅不一的小矩形代表原矩阵中元素值的大小，颜色越深值越小。(b) 矩阵总任意一元素的交互示意，红色小框代表的元素将被相关行列中对应的元素交互影响。(c) 算法收敛后矩阵行列排好序的最终状态，两个绿色框代表的联合簇都被自动发掘出来了。}{width=150mm}{idea}

关于交互的强弱，即“引力”的大小，应该遵循这样的原则：当某些行（或列）之间的距离越小，则说明它们之间的相似性越大，它们越倾向于包含我们想要找寻的联合簇，故越应该受到我们的关注。在这样原则的引导下，我们将对应交互的权重调高，反之若行（或列）间的距离越大，则将对应的交互的权重调小。

这个模型的细节将在第\ref{sec:main}节进行详述，通过这个迭代的加权交互过程，聚类簇已经自动浮现出来了，体现为图中值全部一致的绿色方框，剩下的工作就是用算法将其识别出来。需要注意的是，搜索结果矩阵中值相等的子矩阵也不是一个平凡的问题，若暴力搜索则时间复杂度为指数函数，故我们提出一种巧妙地搜索方法，见第\ref{sec:pattern_search}节。


\section{双边加权交互聚类模型\cosync}
\label{sec:main}
现在将正式引入\cosync的模型定义，首先来对一些符号表示进行说明。

\textbf{符号说明}：对于矩阵$A=(A_I,A_J)$，$A_I$和$A_J$分别为矩阵$A$的行列集合。$a_{i\cdot}\in{}A_I$代表矩阵的第$i$行，$a_{\cdot{}j}\in{}A_J$代表矩阵的第$j$列。一个联合簇可以表示为矩阵$A$的子矩阵，用$B$表示，$B=A(I_S,J_S)$，其中$I_S$为$A_I$的子集的索引集合，$J_S$为$J_S$的$A_J$的子集的索引集合。$a_{ij}$对应着矩阵$A$第$i$行第$j$列的值。

\begin{dingyi}[行或列的$\epsilon$邻域邻居]
给一个矩阵$A$和一个常数$\epsilon\in\mathcal{R}$，任意一行$a_{i\cdot}\in{}A_I$的$\epsilon$邻域邻居可以表示为：
\begin{equation}
N_{\epsilon}^{r}(a_{i\cdot})=\{a_{p\cdot} \big{|} dist(a_{p\cdot}, a_{i\cdot})\leq\epsilon, k \in I\}
\label{def:Nbr}
\end{equation}
其中$dist(\cdot,\cdot)$是一个距离函数，在这里用的是欧几里得距离。列$a_{\cdot{}j}\in{}A_J$的$\epsilon$邻域邻居$N_{\epsilon}^{r}(a_{i\cdot})$按照同样方式定义。
\end{dingyi}

如同Kurumoto model\cite{kuramoto2012chemical}和\Sync算法\cite{shao2011synchronization}中的同步交互模型类似的，我们定义双边模型如下：

\begin{dingyi}[双边交互聚类模型]
\label{def:cosync}
对于矩阵$A$中的元素$a_{ij}$，分别找出其行$a_{i\cdot}$或者列$a_{\cdot{}j}$的$\epsilon$邻域邻居，则邻居行、列中和元素$a_{ij}$交互的值分别为$a_{pj}$和$a_{iq}$，其中$p\in{}N_{\epsilon}^{c}(a_{i.}(t)),q\in{}N_{\epsilon}^{r}(a_{.j}(t))$。在$t$时刻的交互模型为：
\begin{IEEEeqnarray}{rCl}
a_{ij}(t+1) &=& a_{ij}(t)+\frac{1}{2|N_{\epsilon}^{r}(a_{i.}(t))|}\cdot \hspace{-2mm}\sum_{p\in{}N_{\epsilon}^{c}(a_{i.}(t))}\hspace{-5mm}\sin(a_{pj}(t)-a_{ij}(t)) \nonumber
\\
&& \negmedspace{}+\frac{1}{2|N_{\epsilon}^{c}(a_{.j}(t))|}\cdot \hspace{-2mm}\sum_{q\in{}N_{\epsilon}^{r}(a_{.j}(t))}\hspace{-5mm}\sin (a_{iq}(t)-a_{ij}(t))
\end{IEEEeqnarray}
\end{dingyi}

其中$\sin(\cdot)$是耦合函数，$a_{ij}(t+1)$是矩阵元素$A_{ij}$在$t+1(t=(0,\ldots,T))$时刻下的取值，这个交互模型中右边两项分别刻画了矩阵的行、列交互。如同我们在前面所描述的，距离越小的行（或列）的交互影响力应该越大，我们定义一个交互权重因子如下：

\begin{dingyi}[交互权重因子]
对于矩阵元素$A_{ij}$的$\epsilon$邻域行邻居$N_{\epsilon}^{r}(a_{.j}(t))$，其对$A_{ij}$的交互权重因子定义为：
\begin{IEEEeqnarray}{rCl}
w^{r}(j) &=& e^{-\lambda\cdot \sigma_{j}}
\end{IEEEeqnarray}
其中$\sigma_j$为向量$\nu_{pj} =\{ abs(a_{pj} - a_{ij}) \big{|} p\in N_{\epsilon}^{r}(a_{i.}(t))\}$的标准差。同样的，对于$\epsilon$邻域列邻居$N_{\epsilon}^{c}(a_{i.}(t))$的交互权重因子定义为：
\begin{IEEEeqnarray}{rCl}
w^{c}(i) &=& e^{-\lambda\cdot \sigma_{i}}
\end{IEEEeqnarray}
其中$\sigma_i$为向量$\nu_{iq} =\{ abs(a_{iq} - a_{ij}) \big{|} q\in N_{\epsilon}^{c}(a_{.j}(t))\}$的标准差。
\end{dingyi}

\vspace{2mm}
\textbf{双边交互聚类模型}：现在基于新定义的交互权重因子，之前的模型\ref{def:cosync}可以进行改写。这次我们将行、列的交互分开来写为以下形式：
\begin{equation}
I_{row}(t) = \frac{w^{r}(j) }{2|N_{\epsilon}^{r}(a_{i.}(t))|}\cdot \hspace{-2mm}\sum_{p\in
N_{\epsilon}^{r}(a_{i.}(t))}\hspace{-5mm}\sin (a_{pj}(t)-a_{ij}(t))
\label{eq:row}
\end{equation}
\begin{equation}
I_{col}(t) = \frac{w^{c}(i) }{2|N_{\epsilon}^{c}(a_{.j}(t))|}\cdot \hspace{-2mm}\sum_{q\in
N_{\epsilon}^{c}(a_{.j}(t))}\hspace{-5mm}\sin (a_{iq}(t)-a_{ij}(t))
\label{eq:col}
\end{equation}

最后，加权双边交互聚类模型可以写为如下形式：
\begin{equation}
a_{ij}(t+1) = a_{ij}(t)+ I_{row}(t) + I_{col}(t)
\label{eq:model}
\end{equation}

为了衡量矩阵中的同步的程度，从而决定算法的终结，我们引入程度因子$r$如下：
\begin{dingyi}[程度因子]
程度因子$r$在随时间迭代的每一步都会被计算，以决定是否终结加权双边交互算法，其表达式为：
\begin{IEEEeqnarray}{rCl}
r &=&\frac{1}{2|I|}\sum_{i=1}^{|I|}\frac{1}{|N_{\epsilon}^{r}(a_{i.})|}\sum_{p\in N_{\epsilon}^{r}(a_{i.})}\mathbf{e}^{-||a_{p.}-a_{i.}||} \nonumber
\\
&&\negmedspace{}+\frac{1}{2|J|}\sum_{i=1}^{|J|}\frac{1}{|N_{\epsilon}^{c}(a_{.j})|}\sum_{q\in N_{\epsilon}^{c}(a_{.j})}\mathbf{e}^{-||a_{.q}-a_{.j}||}
\end{IEEEeqnarray}
\end{dingyi}
当$r(t)$随着时间$t$收敛，代表着\cosync算法的同步进行到了一定程度，于是可以终结迭代。迭代结束后

\section{结果矩阵上的模式搜索}
\label{sec:pattern_search}

% 值得说明的是矩阵元素间相互作用的耦合函数，首先我们要相互作用的目的是让同一个联合簇间的元素值最终收敛到同一个数值，



% 时域积分方程时间步进算法的阻抗元素直接影响算法的后时稳定性，因此阻
% 抗元素的计算是算法的关键之一，采用精度高效的方法计算时域阻抗元素是时域
% 积分方程时间步进算法研究的重点之一。

% ……
% \section{时域积分方程时间步进算法阻抗矩阵的存储}
% 时域阻抗元素的存储技术也是时间步进算法并行化的关键技术之一\citeup{xiao2012yi}，采用
% 合适的阻抗元素存储方式可以很大的提高并行时间步进算法的计算效率。
% \subsection{时域积分方程时间步进算法产生的阻抗矩阵的特征}
% ……

% 由于时域混合场积分方程是时域电场积分方程与时域磁场积分方程的线性组
% 合，因此时域混合场积分方程时间步进算法的阻抗矩阵特征与时域电场积分方程
% 时间步进算法的阻抗矩阵特征相同。
% \subsection{数值算例与分析}
% ……。如表\ref{tablea}所示给出了时间步长分别取0.4ns、0.5ns、0.6ns 时的三种存储
% 方式的存储量大小。……。
% \pictable[h]{计算$2m*2m$理想导体平板时域感应电流采用的三种存储方式的存储量比较}{}{tablea}

% 如图\ref{picd}所示给出了时间步长选取为0.5ns 时采用三种不同存储方式计算的
% 平板中心处$x$方向的感应电流值与IDFT 方法计算结果的比较，……。如图\ref{pice}
% 所示给出了存储方式为基权函数压缩存储方式，时间步长分别取0.4ns、0.5ns、0.6ns
% 时平板中心处$x$方向的感应电流计算结果，从图中可以看出不同时间步长的计算结果基本相同。

% \begin{pics}[h]{$2m*2m$的理想导体平板中心处感应电流$x$分量随时间的变化关系}{picde}
% \addsubpic{不同存储方式的计算结果与IDFT方法的结果比较}{keepaspectratio,height=5.58cm,width=6.77cm}{picd}
% \addsubpic{不同时间步长的计算结果比较}{keepaspectratio=false,height=5.48cm,width=7.04cm}{pice}
% \end{pics}
% %
% 由于时域混合场积分方程是时域电场积分方程与时域磁场积分方程的线性组
% 合，因此时域混合场积分方程时间步进算法的阻抗矩阵特征与时域电场积分方程
% 时间步进算法的阻抗矩阵特征相同。
% \section{时域积分方程时间步进算法矩阵方程的求解}
% ……

% \begin{dingli}
% 如果时域混合场积分方程是时域电场积分方程与时域磁场积分方程
% 的线性组合……
% \end{dingli}
% \begin{zhengming}
% 首先，由于……

% ……\\
% 根据……，结论得证。
% \end{zhengming}
% \section{本章小结}
% 本章首先研究了时域积分方程时间步进算法的阻抗元素精确计算技术，分别
% 采用DUFFY 变换法与卷积积分精度计算法计算时域阻抗元素，通过算例验证了计
% 算方法的高精度。……
